#!/usr/bin/env python
# -*- coding: utf-8 -*-
#** -----------------------------------------------------------------------------------------------
#*  pyACME
#*  Copyright (c) 2010, Milton Abrunhosa
#*  -----------------------------------------------------------------------------------------------
#*  Package..: SiPAR
#*  Classe...: clsTabelaPAR
#*
#*  Descrição: mantém a tabela de PAR's
#*  -----------------------------------------------------------------------------------------------
#*  Detalhes de Alteração
#*  -----------------------------------------------------------------------------------------------
#*  well     1997/fev/12  versão 1.0 started
#*  mlabru   2009/set/01  versão 3.0 started
#*  -----------------------------------------------------------------------------------------------
#*  Detalhes de Versão
#*  -----------------------------------------------------------------------------------------------
#*  start    1997/fev/12  versão inicial (DOS/Modula-2)
#*  3.01-01  2009/set/01  versão para Linux
#*  -----------------------------------------------------------------------------------------------
#*/

#** -----------------------------------------------------------------------------------------------
#*  includes
#*  -----------------------------------------------------------------------------------------------
#*/

#/ Python library
#/ ------------------------------------------------------------------------------------------------
import bisect

#/ log4Py (logger)
#/ ------------------------------------------------------------------------------------------------
import logging

#/ PyQt library
#/ ------------------------------------------------------------------------------------------------
from PyQt4 import QtCore

#/ SiPAR / model
#/ ------------------------------------------------------------------------------------------------
import model.clsPAR as clsPAR
import model.clsTabelaModel as clsTabelaModel

import model.glbDefs as glbDefs
import model.locDefs as locDefs

#** -----------------------------------------------------------------------------------------------
#*  variáveis globais
#*  -----------------------------------------------------------------------------------------------
#*/

#/ logging level
#/ ------------------------------------------------------------------------------------------------
#w_logLvl = logging.INFO
w_logLvl = logging.DEBUG

#** -----------------------------------------------------------------------------------------------
#*  clsTabelaPAR::clsTabelaPAR
#*  -----------------------------------------------------------------------------------------------
#*  a Tabela de PAR's mantém o conjunto dos PAR's. Os PAR's são mantidas ordenados por sua chave,
#*  assim se este campo for alterado as PAR's devem ser re-ordenados. Por esta razão (e para manter
#*  o flag de alteração), todas as atualizações dever ser feitas através do método updateTabelaPAR
#*  desta classe.
#*  -----------------------------------------------------------------------------------------------
#*/
class clsTabelaPAR ( clsTabelaModel.clsTabelaModel ):

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::__init__
    #*  -------------------------------------------------------------------------------------------
    #*  inicia a tabela de PAR's
    #*  -------------------------------------------------------------------------------------------
    #*  @param  nenhum
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def __init__ ( self ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::__init__"


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*  inicia a super class
        #*/
        clsTabelaModel.clsTabelaModel.__init__ ( self )
                               
        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log.debug ( "<< " )

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::exportXML
    #*  -------------------------------------------------------------------------------------------
    #*  exporta a tabela como um arquivo XML
    #*  -------------------------------------------------------------------------------------------
    #*  @param  f_szFName - DOCUMENT ME!
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def exportXML ( self, f_szFName ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::exportXML"

        #/ file descriptor
        #/ ----------------------------------------------------------------------------------------
        l_fdIn = None

        #/ mensagem de erro
        #/ ----------------------------------------------------------------------------------------
        l_szErro = None


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*/
        try:

            #** -----------------------------------------------------------------------------------
            #*/
            l_fdIn = QtCore.QFile ( f_szFName )
            #assert ( l_fdIn )

            #** -----------------------------------------------------------------------------------
            #*/
            if ( not l_fdIn.open ( QtCore.QIODevice.WriteOnly )):

                #** -------------------------------------------------------------------------------
                #*/
                raise IOError, unicode ( l_fdIn.errorString ())

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream = QtCore.QTextStream ( l_fdIn )
            #assert ( l_stream )

            l_stream.setCodec ( glbDefs.xUNI_CODEC )

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream << ( "<?xml version='1.0' encoding='{0}'?>\n"
                          "<!DOCTYPE TABPAR>\n"
                          "<TABPAR VERSION='1.0'>\n".format ( glbDefs.xUNI_CODEC ))

            #** -----------------------------------------------------------------------------------
            #*/
            for _, l_PAR in self._aItens:

                #** -------------------------------------------------------------------------------
                #*/
                l_stream << "<PAR Key='{0}' Descricao='{1}'>\n".format ( l_PAR._szKey, l_PAR._szDescr.replace ( ' ', '_' )) \
                         << "<CAB>"   << l_PAR._iCab0 << "</CAB>\n" \
                         << "<HANT0>" << l_PAR._fHAnt0 << "</HANT0>\n" \
                         << "<HANT1>" << l_PAR._fHAnt1 << "</HANT1>\n" \
                         << "<DAE>" << l_PAR._fDstAntEixo << "</DAE>\n" \
                         << "<DAPT0>" << l_PAR._fDstAntPT0 << "</DAPT0>\n" \
                         << "<DAPT1>" << l_PAR._fDstAntPT1 << "</DAPT1>\n" \
                         << "<ANGR>" << l_PAR._fAngRampa << "</ANGR>\n" \
                         << "<RET>" << l_PAR._aiRetardo [ 0 ] << "</RET>\n" \
                         << "<DECL>" << l_PAR._iDecl << "</DECL>\n" \
                         << "</PAR>\n"

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream << "</TABPAR>\n"

        #** ---------------------------------------------------------------------------------------
        #*/
        except ( IOError, OSError ), e:

            #** -----------------------------------------------------------------------------------
            #*/
            l_szErro = u"Erro na exportação: {0}".format ( e )

        #** ---------------------------------------------------------------------------------------
        #*/
        finally:

            #** -----------------------------------------------------------------------------------
            #*/
            if ( l_fdIn is not None ):

                #** -------------------------------------------------------------------------------
                #*/
                l_fdIn.close ()

            #** -----------------------------------------------------------------------------------
            #*/
            if ( l_szErro is not None ):

                #** -------------------------------------------------------------------------------
                #*  m.poirot logger
                #*/
                #l_log.debug ( "<< " )

                #** -------------------------------------------------------------------------------
                #*/
                return ( False, l_szErro )

            #** -----------------------------------------------------------------------------------
            #*/
            self._bDirty = False

            #** -----------------------------------------------------------------------------------
            #*  m.poirot logger
            #*/
            #l_log.debug ( "<< " )

            #** -----------------------------------------------------------------------------------
            #*/
            return ( True, "{0} registros exportados para {1}".format ( len ( self._aItens ),
                                                               QtCore.QFileInfo ( f_szFName ).fileName ()))

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::loadQDataStream
    #*  -------------------------------------------------------------------------------------------
    #*  DOCUMENT ME!
    #*  -------------------------------------------------------------------------------------------
    #*  @param  nenhum
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def loadQDataStream ( self ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::loadQDataStream"

        #/ file descriptor
        #/ ----------------------------------------------------------------------------------------
        l_fdIn = None

        #/ mensagem de erro
        #/ ----------------------------------------------------------------------------------------
        l_szErro = None


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*  tenta carregar o arquivo...
        #*/
        try:

            #** -----------------------------------------------------------------------------------
            #*  abre o arquivo
            #*/
            l_fdIn = QtCore.QFile ( self._szFName )
            #assert ( l_fdIn )

            #** -----------------------------------------------------------------------------------
            #*  erro na abertura ?
            #*/
            if ( not l_fdIn.open ( QtCore.QIODevice.ReadOnly )):

                #** -------------------------------------------------------------------------------
                #*  gera exception
                #*/
                raise IOError, unicode ( l_fdIn.errorString ())

            #** -----------------------------------------------------------------------------------
            #*  acessa o arquivo como uma stream de dados
            #*/
            l_stream = QtCore.QDataStream ( l_fdIn )
            #assert ( l_stream )

            #** -----------------------------------------------------------------------------------
            #*  le o magic number
            #*/
            l_iMagic = l_stream.readInt32 ()

            #** -----------------------------------------------------------------------------------
            #*  tipo de arquivo valido ?
            #*/
            if ( clsTabelaModel.c_xxMAGIC_NUMBER != l_iMagic ):

                #** -------------------------------------------------------------------------------
                #*  gera exception
                #*/
                raise IOError, u"tipo de arquivo não reconhecido !"

            #** -----------------------------------------------------------------------------------
            #*  le a versao do arquivo
            #*/
            l_iVersion = l_stream.readInt32 ()

            #** -----------------------------------------------------------------------------------
            #*  versao muito antiga ?
            #*/
            if ( l_iVersion < clsTabelaModel.c_xxOLD_FILE_VERSION ):

                #** -------------------------------------------------------------------------------
                #*  gera exception
                #*/
                raise IOError, u"formato do arquivo é antigo e não legível !"

            #** -----------------------------------------------------------------------------------
            #*  versao nova ?
            #*/
            elif ( l_iVersion > clsTabelaModel.c_xxFILE_VERSION ):

                #** -------------------------------------------------------------------------------
                #*  gera exception
                #*/
                raise IOError, u"formato do arquivo é novo e não legível !"

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream.setVersion ( QtCore.QDataStream.Qt_4_2 )

            #** -----------------------------------------------------------------------------------
            #*/
            self.clear ( False )

            #** -----------------------------------------------------------------------------------
            #*  enquanto nao termina de ler a stream...
            #*/
            while ( not l_stream.atEnd ()):

                #** -------------------------------------------------------------------------------
                #*  cria a área para chave do PAR
                #*/
                l_szKey = QtCore.QString ()

                #** -------------------------------------------------------------------------------
                #*  lê a chave do PAR
                #*/
                l_stream >> l_szKey

                #** -------------------------------------------------------------------------------
                #*  cria a área para descrição do PAR
                #*/
                l_szDescr = QtCore.QString ()

                #** -------------------------------------------------------------------------------
                #*  lê a descrição do PAR
                #*/
                l_stream >> l_szDescr
                l_szDescr = l_szDescr.replace ( '_', ' ' )

                #** -------------------------------------------------------------------------------
                #*  lê a cabeceira principal
                #*/
                l_iCab0 = l_stream.readInt ()

                #** -------------------------------------------------------------------------------
                #*  lê a altura da antena relativo ao ponto toque principal
                #*/
                l_fHAnt0 = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê a altura da antena relativo ao ponto toque secundário
                #*/
                l_fHAnt1 = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê o afastamento da antena ao eixo da pista
                #*/
                l_fDstAntEixo = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê a distância da antena ao ponto toque principal
                #*/
                l_fDstAntPT0 = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê a distância da antena ao ponto toque secundário
                #*/
                l_fDstAntPT1 = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê o ângulo da rampa de aproximação
                #*/
                l_fAngRampa = l_stream.readFloat ()

                #** -------------------------------------------------------------------------------
                #*  lê o retardo
                #*/
                l_iRetardo = l_stream.readInt ()

                #** -------------------------------------------------------------------------------
                #*  lê a declinação magnética
                #*/
                l_iDecl = l_stream.readInt ()

                #** -------------------------------------------------------------------------------
                #*  cria o PAR e coloca na tabela de PARs
                #*/
                self.add ( clsPAR.clsPAR ( [ l_szKey, l_szDescr, l_iCab0, l_fHAnt0, l_fHAnt1,
                                             l_fDstAntEixo, l_fDstAntPT0, l_fDstAntPT1, l_fAngRampa,
                                             l_iRetardo, l_iDecl ] ), l_szKey )

        #** ---------------------------------------------------------------------------------------
        #*/
        except ( IOError, OSError ), e:

            #** -----------------------------------------------------------------------------------
            #*  cria a mensagem de erro
            #*/
            l_szErro = "Erro na carga: {0}".format ( e )

        #** ---------------------------------------------------------------------------------------
        #*/
        finally:

            #** -----------------------------------------------------------------------------------
            #*  o arquivo foi aberto ?
            #*/
            if ( l_fdIn is not None ):

                #** -------------------------------------------------------------------------------
                #*  fecha o arquivo
                #*/
                l_fdIn.close ()

            #** -----------------------------------------------------------------------------------
            #*  ocorreu alguma exception ?
            #*/
            if ( l_szErro is not None ):

                #** -------------------------------------------------------------------------------
                #*  m.poirot logger
                #*/
                #l_log.debug ( "<< " )

                #** -------------------------------------------------------------------------------
                #*  avisa do erro e cai fora
                #*/
                return ( False, l_szErro )

            #** -----------------------------------------------------------------------------------
            #*  reseta flag
            #*/
            self._bDirty = False

            #** -----------------------------------------------------------------------------------
            #*  m.poirot logger
            #*/
            #l_log.debug ( "<< " )

            #** -----------------------------------------------------------------------------------
            #*/
            return ( True, "{0} PARs carregadas de {1}".format ( len ( self._aItens ),
                                                        QtCore.QFileInfo ( self._szFName ).fileName ()))

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::populateFromData
    #*  -------------------------------------------------------------------------------------------
    #*  carrega os dados do PAR PAR
    #*  -------------------------------------------------------------------------------------------
    #*  @param  f_lstData - DOCUMENT ME!
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def populateFromData ( self, f_lstData ):

        #/ globals
        #/ ----------------------------------------------------------------------------------------
        #global locDefs.xMAX_PAR

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::populateFromData"


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*  zera índices
        #*/
        l_iD = 0

        #** ---------------------------------------------------------------------------------------
        #*  calcula o número de PARs na tabela
        #*/
        locDefs.xMAX_PAR = ( len ( f_lstData ) // 11 )
        ##l_log.info ( "locDefs.xMAX_PAR: " + str ( locDefs.xMAX_PAR ))

        #** ---------------------------------------------------------------------------------------
        #*  cria a tabela de PARs
        #*/
        self._tabItens = [ None for _ in xrange ( locDefs.xMAX_PAR ) ]
        #assert ( self._tabItens )

        ##l_log.info ( "self._tabItens: " + str ( self._tabItens ))

        #** ---------------------------------------------------------------------------------------
        #*  carrega os dados da tabela de PARs
        #*/
        for _ in xrange ( locDefs.xMAX_PAR ):

            ##l_log.info ( "l_btPAR: " + str ( l_btPAR ))

            #** -----------------------------------------------------------------------------------
            #*  chave do PAR
            #*/
            l_szKey = str ( f_lstData [ l_iD ] ).upper ()
            l_iD += 1

            ##l_log.info ( "_szKey: " + str ( l_szKey ))

            #** -----------------------------------------------------------------------------------
            #*  descrição do PAR
            #*/
            l_szDescr = str ( f_lstData [ l_iD ] ).upper ().replace ( '_', ' ' )
            l_iD += 1

            ##l_log.info ( "_szDescr: " + str ( l_szDescr ))

            #** -----------------------------------------------------------------------------------
            #*  carrega as pistas
            #*/
            l_iCab0 = int ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_iCab0: " + str ( l_iCab0 ))

            #** -----------------------------------------------------------------------------------
            #*  altura da antena relativo ao ponto toque principal
            #*/
            l_fHAnt0 = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fHAnt0: " + str ( l_fHAnt0 ))

            #** -----------------------------------------------------------------------------------
            #*  altura da antena relativo ao ponto toque secundário
            #*/
            l_fHAnt1 = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fHAnt1: " + str ( l_fHAnt1 ))

            #** -----------------------------------------------------------------------------------
            #*  afastamento da antena ao eixo da pista
            #*/
            l_fDstAntEixo = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fDstAntEixo: " + str ( l_fDstAntEixo ))

            #** -----------------------------------------------------------------------------------
            #*  distância da antena ao ponto toque principal
            #*/
            l_fDstAntPT0 = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fDstAntPT0: " + str ( l_fDstAntPT0 ))

            #** -----------------------------------------------------------------------------------
            #*  distância da antena ao ponto toque secundário
            #*/
            l_fDstAntPT1 = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fDstAntPT1: " + str ( l_fDstAntPT1 ))

            #** -----------------------------------------------------------------------------------
            #*  angulo da rampa de aproximacao
            #*/
            l_fAngRampa = float ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_fAngRampa: " + str ( l_fAngRampa ))

            #** -----------------------------------------------------------------------------------
            #*  carrega os retardos
            #*/
            l_iRetardo = int ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_iRetardo: " + str ( l_iRetardo ))

            #** -----------------------------------------------------------------------------------
            #*  declinação magnética do PAR
            #*/
            l_iDecl = int ( f_lstData [ l_iD ] )
            l_iD += 1

            ##l_log.info ( "_iDecl: " + str ( l_iDecl ))

            #** -----------------------------------------------------------------------------------
            #*  cria a PAR
            #*/
            l_PAR = clsPAR.clsPAR ( [ l_szKey, l_szDescr, l_iCab0, l_fHAnt0, l_fHAnt1,
                                      l_fDstAntEixo, l_fDstAntPT0, l_fDstAntPT1, l_fAngRampa,
                                      l_iRetardo, l_iDecl ] )
            #assert ( l_PAR )

            #** -----------------------------------------------------------------------------------
            #*  coloca o PAR na tabela de PARs
            #*/
            self.add ( l_PAR, l_szKey )

        #** ---------------------------------------------------------------------------------------
        #*  após a carga, reseta o flag dirty
        #*/
        self._bDirty = False
        ##l_log.info ( "self._bDirty: " + str ( self._bDirty ))

        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log.debug ( "<< " )

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::saveQDataStream
    #*  -------------------------------------------------------------------------------------------
    #*  DOCUMENT ME!
    #*  -------------------------------------------------------------------------------------------
    #*  @param  nenhum
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def saveQDataStream ( self ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::saveQDataStream"

        #/ file descriptor do arquivo de saída
        #/ ----------------------------------------------------------------------------------------
        l_fdOut = None

        #/ mensagem de erro
        #/ ----------------------------------------------------------------------------------------
        l_szError = None


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*/
        try:

            #** -----------------------------------------------------------------------------------
            #*/
            l_fdOut = QtCore.QFile ( self._szFName )
            #assert ( l_fdOut )

            #** -----------------------------------------------------------------------------------
            #*/
            if ( not l_fdOut.open ( QtCore.QIODevice.WriteOnly )):

                #** -------------------------------------------------------------------------------
                #*/
                raise IOError, unicode ( l_fdOut.errorString ())

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream = QtCore.QDataStream ( l_fdOut )
            #assert ( l_stream )

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream.writeInt32 ( clsTabelaPAR.c_xxMAGIC_NUMBER )

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream.writeInt32 ( clsTabelaPAR.c_xxFILE_VERSION )

            #** -----------------------------------------------------------------------------------
            #*/
            l_stream.setVersion ( QtCore.QDataStream.Qt_4_2 )

            #** -----------------------------------------------------------------------------------
            #*/
            for _, l_PAR in self._aItens:

                #** -------------------------------------------------------------------------------
                #*/
                l_stream << l_PAR._szKey

                #** -------------------------------------------------------------------------------
                #*/
                l_stream << l_PAR._szDescr.replace ( ' ', '_' )

                #** -------------------------------------------------------------------------------
                #*  grava a cabeceira principal
                #*/
                l_stream.writeInt ( l_PAR._iCab0 )

                #** -------------------------------------------------------------------------------
                #*  grava a altura da antena relativo ao ponto toque principal
                #*/
                l_stream.writeFloat ( l_PAR._fHAnt0 )

                #** -------------------------------------------------------------------------------
                #*  grava a altura da antena relativo ao ponto toque secundário
                #*/
                l_stream.writeFloat ( l_PAR._fHAnt1 )

                #** -------------------------------------------------------------------------------
                #*  grava o afastamento da antena ao eixo da pista
                #*/
                l_stream.writeFloat ( l_PAR._fDstAntEixo )

                #** -------------------------------------------------------------------------------
                #*  grava a distância da antena ao ponto toque principal
                #*/
                l_stream.writeFloat ( l_PAR._fDstAntPT0 )

                #** -------------------------------------------------------------------------------
                #*  grava a distância da antena ao ponto toque secundário
                #*/
                l_stream.writeFloat ( l_PAR._fDstAntPT1 )

                #** -------------------------------------------------------------------------------
                #*  grava o ângulo da rampa de aproximação
                #*/
                l_stream.writeFloat ( l_PAR._fAngRampa )

                #** -------------------------------------------------------------------------------
                #*  grava o retardo
                #*/
                l_stream.writeInt ( l_PAR._aiRetardo [ 0 ] )

                #** -------------------------------------------------------------------------------
                #*  grava a declinação magnética
                #*/
                l_stream.writeInt ( l_PAR._iDecl )

        #** ---------------------------------------------------------------------------------------
        #*/
        except ( IOError, OSError ), e:

            #** -----------------------------------------------------------------------------------
            #*/
            l_szError = "Erro no salvamento: {0}".format ( e )

        #** ---------------------------------------------------------------------------------------
        #*/
        finally:

            #** -----------------------------------------------------------------------------------
            #*/
            if ( l_fdOut is not None ):

                #** -------------------------------------------------------------------------------
                #*/
                l_fdOut.close ()

            #** -----------------------------------------------------------------------------------
            #*/
            if ( l_szError is not None ):

                #** -------------------------------------------------------------------------------
                #*  m.poirot logger
                #*/
                #l_log.debug ( "<< " )

                #** -------------------------------------------------------------------------------
                #*/
                return ( False, l_szError )

            #** -----------------------------------------------------------------------------------
            #*/
            self._bDirty = False

            #** -----------------------------------------------------------------------------------
            #*  m.poirot logger
            #*/
            #l_log.debug ( "<< " )

            #** -----------------------------------------------------------------------------------
            #*/
            return ( True, "Salvos {0} PARs em {1}".format ( len ( self._aItens ),
                                                    QtCore.QFileInfo ( self._szFName ).fileName ()))

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::saveTextData
    #*  -------------------------------------------------------------------------------------------
    #*  DOCUMENT ME!
    #*  -------------------------------------------------------------------------------------------
    #*  @param  nenhum
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def saveTextData ( self ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::saveTextData"

        #/ mensagem de erro
        #/ ----------------------------------------------------------------------------------------
        l_szError = None


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*  nome da tabela de PAR's
        #*/
        #assert ( self._szFName )
        ##l_log.info ( "Tabela de PAR's a salvar: " + self._szFName )

        #** ---------------------------------------------------------------------------------------
        #*/
        try:

            #** -----------------------------------------------------------------------------------
            #*  abre o arquivo de PAR
            #*/
            l_fdPAR = open ( self._szFName, "w" )
            #assert ( l_fdPAR )

            #** -----------------------------------------------------------------------------------
            #*  percorre todos os PAR's
            #*/
            for _, l_PAR in self._aItens:

                #** -------------------------------------------------------------------------------
                #*  cria a area de dados
                #*/
                l_lstData = "%s %s %d %.1f %.1f %.1f %.1f %.1f %.1f %d %d\n" % \
                            ( l_PAR._szKey, l_PAR._szDescr.replace ( ' ', '_' ),
                              l_PAR._iCab0, l_PAR._fHAnt0, l_PAR._fHAnt1,
                              l_PAR._fDstAntEixo, l_PAR._fDstAntPT0, l_PAR._fDstAntPT1,
                              l_PAR._fAngRampa, l_PAR._aiRetardo [ 0 ], l_PAR._iDecl )

                #** -------------------------------------------------------------------------------
                #*  grava no arquivo
                #*/
                l_fdPAR.write ( l_lstData )

            #** -----------------------------------------------------------------------------------
            #*  fecha o arquivo
            #*/
            l_fdPAR.close ()

            #** -----------------------------------------------------------------------------------
            #*  m.poirot logger
            #*/
            #l_log.debug ( "<< " )

            #** -----------------------------------------------------------------------------------
            #*/
            return ( True, "Salvos {0} PARs em {1}".format ( len ( self._aItens ),
                                                    QtCore.QFileInfo ( self._szFName ).fileName ()))

        #** ---------------------------------------------------------------------------------------
        #*/
        except ( IOError, OSError ), e:

            #** -----------------------------------------------------------------------------------
            #*/
            l_szError = "Erro no salvamento: {0}".format ( e )

        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log.debug ( "<< " )

        #** ---------------------------------------------------------------------------------------
        #*/
        return ( False, l_szError )

    #** -------------------------------------------------------------------------------------------
    #*  clsTabelaPAR::updateTabela
    #*  -------------------------------------------------------------------------------------------
    #*  DOCUMENT ME!
    #*  -------------------------------------------------------------------------------------------
    #*  @param  f_PAR     - DOCUMENT ME!
    #*  @param  f_lstData - DOCUMENT ME!
    #*
    #*  @return nenhum
    #*  -------------------------------------------------------------------------------------------
    #*/
    def updateTabela ( self, f_PAR, f_lstData ):

        #/ nome do método (logger)
        #/ ----------------------------------------------------------------------------------------
        #l_szMetodo = "clsTabelaPAR::updateTabela"


        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log = logging.getLogger ( l_szMetodo )
        #l_log.setLevel ( w_logLvl )
        #l_log.debug ( ">> " )

        #** ---------------------------------------------------------------------------------------
        #*  descricao do PAR PAR
        #*/
        if ( None != f_lstData [ 1 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._szDescr = str ( f_lstData [ 1 ] ).upper ()

        #** ---------------------------------------------------------------------------------------
        #*  cabeceira principal
        #*/
        if ( None != f_lstData [ 2 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._iCab0 = int ( f_lstData [ 2 ] )

        #** ---------------------------------------------------------------------------------------
        #*  altura da antena relativo ao ponto toque principal
        #*/
        if ( None != f_lstData [ 3 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fHAnt0 = float ( f_lstData [ 3 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fHAnt0 = 13.0

        #** ---------------------------------------------------------------------------------------
        #*  altura da antena relativo ao ponto toque secundário
        #*/
        if ( None != f_lstData [ 4 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fHAnt1 = float ( f_lstData [ 4 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fHAnt1 = 13.0

        #** ---------------------------------------------------------------------------------------
        #*  afastamento da antena ao eixo da pista
        #*/
        if ( None != f_lstData [ 5 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fDstAntEixo = float ( f_lstData [ 5 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fDstAntEixo = 150.0

        #** ---------------------------------------------------------------------------------------
        #*/
        if ( f_PAR._fDstAntEixo < 100.0 ):

            print u'Afastamento antena eixo da pista incompatível com recomendações ICAO.'

        #** ---------------------------------------------------------------------------------------
        #*  distância da antena ao ponto toque principal
        #*/
        if ( None != f_lstData [ 6 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fDstAntPT0 = float ( f_lstData [ 6 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fDstAntPT0 = 1000.0

        #** ---------------------------------------------------------------------------------------
        #*/
        if (( f_PAR._fDstAntEixo >= 100.0 ) and ( f_PAR._fDstAntEixo <= 185.0 )):

            if ( f_PAR._fDstAntPT0 < 685.0 ):

                print u'Distância antena ao ponto de toque incompatível com recomendações da ICAO.'

        elif ( f_PAR._fDstAntPT0 < 915.0 ):

            print u'Distância antena ao ponto de toque incompatível com recomendações da ICAO.'

        #** ---------------------------------------------------------------------------------------
        #*  distância da antena ao ponto toque secundário
        #*/
        if ( None != f_lstData [ 7 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fDstAntPT1 = float ( f_lstData [ 7 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fDstAntPT1 = 1150.0

        #** ---------------------------------------------------------------------------------------
        #*  angulo da rampa de aproximacao
        #*/
        if ( None != f_lstData [ 8 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega o valor informado
            #*/
            f_PAR._fAngRampa = float ( f_lstData [ 8 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        else:

            #** -----------------------------------------------------------------------------------
            #*  carrega um valor default
            #*/
            f_PAR._fAngRampa = 3.0

        #** ---------------------------------------------------------------------------------------
        #*  carrega os retardos
        #*/
        if ( None != f_lstData [ 9 ] ):

            #** -----------------------------------------------------------------------------------
            #*  carrega os retardos
            #*/
            for l_iEsc in xrange ( locDefs.xMAX_Escalas ):

                #** -------------------------------------------------------------------------------
                #*/
                f_PAR._aiRetardo [ l_iEsc ] = int ( f_lstData [ 9 ] )

        #** ---------------------------------------------------------------------------------------
        #*/
        if ( str ( f_lstData [ 0 ] ).upper () != f_PAR._szKey ):

            #** -----------------------------------------------------------------------------------
            #*/
            l_key = self.key ( f_PAR._szKey )

            #** -----------------------------------------------------------------------------------
            #*/
            l_iI = bisect.bisect_left ( self._aItens, [ l_key, f_PAR ] )

            #** -----------------------------------------------------------------------------------
            #*/
            self._aItens [ l_iI ][ 0 ] = self.key ( str ( f_lstData [ 0 ] ).upper ())

            #** -----------------------------------------------------------------------------------
            #*/
            f_PAR._szKey = str ( f_lstData [ 0 ] ).upper ()

            #** -----------------------------------------------------------------------------------
            #*/
            self._aItens.sort ()

        #** ---------------------------------------------------------------------------------------
        #*/
        self._bDirty = True

        #** ---------------------------------------------------------------------------------------
        #*  m.poirot logger
        #*/
        #l_log.debug ( "<< " )

    #** ===========================================================================================
    #*  rotinas de exportação de entrada da tabela de PAR's
    #*  ===========================================================================================
    #*/

#** -----------------------------------------------------------------------------------------------
#*/
logger = logging.getLogger ( "clsTabelaPAR" )

#** -----------------------------------------------------------------------------------------------
#*/
logger.setLevel ( w_logLvl )

#** ----------------------------------------------------------------------------------------------- *#
